@tool
extends Node3D
class_name VehicleFuselage3D

## A node used as a child of a [VehicleBody3D] parent to simple simulate the behavior of fuselage.

@export_group("Shape")
## Fuselage length
@export var length := 1.0:
	set(value):
		length = value
		_dirty = true
		update_gizmos()
## Front fuselage width
@export var front_width := 0.25:
	set(value):
		front_width = value
		_dirty = true
		update_gizmos()
## Rear fuselage width
@export var rear_width := 0.1:
	set(value):
		rear_width = value
		_dirty = true
		update_gizmos()
## Mid-fuselage width
@export var midpoint_width := 1.0:
	set(value):
		midpoint_width = value
		_dirty = true
		update_gizmos()
## Position of the midpoint
@export_range(0.0, 1.0) var midpoint := 0.25:
	set(value):
		midpoint = value
		_dirty = true
		update_gizmos()
## Adds a perpendicular plane to simulate a cylinder
@export var cylinder := false:
	set(value):
		cylinder = value
		_dirty = true
		update_gizmos()

@export_group("Aerodynamic")
## Zero-Angle-of-Attack drag coefficient
@export var zero_angle_drag := 0.023
## Max drag coefficient (0.5 - cylinder, 2.2 - plane)
@export var drag_max := 1.0
## Air density.
@export var density := 1.2255

@export_group("Debug")
## Enables debug view of wing sections
@export var debug: bool:
	set(value):
		if value != debug:
			debug = value
			_update_debug_view()


class Section:
	var transform: Transform3D
	var global_transform: Transform3D
	var length: float
	var width: float
	var force: Vector3

var _force: Vector3
var _torque: Vector3
var _body: RigidBody3D
var _dirty := true
var _sections: Array[Section]
var _debug_view: Node3D


func _enter_tree() -> void:
	_body = get_parent() as RigidBody3D
	_try_rebuild()


func _exit_tree() -> void:
	_body = null


func _physics_process(delta: float) -> void:
	if _body == null or Engine.is_editor_hint():
		return
	var state := PhysicsServer3D.body_get_direct_state(_body.get_rid())
	if state != null:
		calculate(state.linear_velocity, state.angular_velocity, _body.transform * state.center_of_mass_local)
		_body.apply_central_force(_force)
		_body.apply_torque(_torque)


## Ðœanual calculation of the force and torque generated by the fuselage. For example, to plot graphs.
func calculate(linear_velocity: Vector3, angular_velocity: Vector3, center_of_mass: Vector3) -> void:
	_try_rebuild()
	_force = Vector3.ZERO
	_torque = Vector3.ZERO

	for section in _sections:
		section.global_transform = global_transform * section.transform
		var arm := section.global_transform.origin - center_of_mass
		var wind := -(linear_velocity + angular_velocity.cross(arm))
		_calculate_section_forces(section, wind)
		_force += section.force
		_torque += arm.cross(section.force)


## Returns the force generated by the fuselage.
func get_force() -> Vector3:
	return _force


## Returns the force generated by the fuselage.
func get_torque() -> Vector3:
	return _torque


## Returns the number of fuselage sections.
func get_section_count() -> int:
	return len(_sections)


## Returns the width of the fuselage section.
func get_section_width(index: int) -> float:
	return _sections[index].width


## Returns the length of the fuselage section.
func get_section_length(index: int) -> float:
	return _sections[index].length


## Returns the transform of the fuselage section.
func get_section_transform(index: int) -> Transform3D:
	return _sections[index].transform


func _calculate_section_forces(section: Section, wind: Vector3) -> void:
	var area := section.width * section.length
	var up := section.global_transform.basis.y.normalized()
	var wind_direction := wind.normalized()
	var drag_factor := zero_angle_drag + absf(up.dot(wind_direction)) * drag_max
	var force := 0.5 * drag_factor * wind * wind.length() * area * density
	section.force += (force - section.force) * 0.5


func _get_configuration_warnings() -> PackedStringArray:
	var warnings := PackedStringArray()
	if get_parent() is not RigidBody3D:
		warnings.append("VehicleFuselage3D serves to provide a aerodynamic to a VehicleBody3D or RigidBody3D. Please use it as a child of a VehicleBody3D or RigidBody3D.")
	return warnings


func _try_rebuild() -> void:
	if not _dirty:
		return
	_sections.clear()
	_dirty = false
	_build_sections()
	if _debug_view != null:
		_debug_view.build()


func _build_sections() -> void:
	var forward := -transform.basis.z.normalized()
	var forward_point := forward * length * 0.5
	var backward_point := -forward_point
	if midpoint > 0.0 and midpoint < 1.0:
		var center := forward * length * (0.5 - midpoint)
		_build_part(center, forward_point, midpoint_width, front_width)
		_build_part(center, backward_point, midpoint_width, rear_width)
	else:
		_build_part(backward_point, forward_point, rear_width, front_width)


func _build_part(base: Vector3, tip: Vector3, width_base: float, width_tip: float) -> void:
	var part_length := (tip - base).length()
	var nominal_section_length := _get_nominal_section_length(width_base, width_tip, part_length)
	if nominal_section_length <= 0.0:
		return
	var taper := width_tip / width_base
	var section_count := ceili(1.0 / nominal_section_length)
	var section_length := part_length / section_count
	for i in section_count:
		var fraction := (i + 0.5) / section_count
		var section_position := base + (tip - base) * fraction
		var section_width := width_base * (1.0 - (1.0 - taper) * fraction)
		_sections.append(_create_section(section_position, section_width, section_length, false))
		if cylinder:
			_sections.append(_create_section(section_position, section_width, section_length, true))


func _create_section(section_position, section_width, section_length, section_cylinder: bool) -> Section:
	var section := Section.new()
	section.length = section_length
	section.width = section_width
	var algle := PI / 2 if section_cylinder else 0.0
	section.transform = Transform3D(Basis.from_euler(Vector3(0.0, 0.0, algle)), section_position)
	return section


func _get_nominal_section_length(width_base: float, tip_width: float, part_length: float) -> float:
	var max_width := maxf(width_base, maxf(tip_width, midpoint_width))
	var section_length := max_width / part_length
	if section_length <= 0.0:
		return 0.0
	var section_count := ceili(1.0 / section_length)
	return section_length


var VehicleFuselage3DDebugView := preload("uid://crwh0p1vje6as")
func _update_debug_view() -> void:
	if _debug_view != null:
		_debug_view.queue_free()
		_debug_view = null
	if debug:
		_debug_view = VehicleFuselage3DDebugView.new()
		add_child(_debug_view)
