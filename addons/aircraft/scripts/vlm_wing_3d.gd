@tool
@icon("uid://dgp1egfjl2whe")
extends Node3D
class_name VlmWing3D

@export_group("Shape")
## Wing span. Distance between wingtips.
@export var span := 4.0:
	set(value):
		span = value
		_dirty = true
		update_gizmos()

## Wing chord at the base.
@export var chord := 0.5:
	set(value):
		chord = value
		_dirty = true
		update_gizmos()

## Taper of the wing at the tip relative to the base.
@export_range(0, 1) var taper := 1.0:
	set(value):
		taper = value
		_dirty = true
		update_gizmos()

## Wing twist angle.
@export_range(-15, 15, 0.001, "radians_as_degrees") var twist := 0.0:
	set(value):
		twist = value
		_dirty = true
		update_gizmos()

## Wing sweep angle.
@export_range(-70, 70, 0.001, "radians_as_degrees") var sweep := 0.0:
	set(value):
		sweep = value
		_dirty = true
		update_gizmos()

## Wing dihedral angle.
@export_range(-30, 30, 0.001, "radians_as_degrees") var dihedral := 0.0:
	set(value):
		dihedral = value
		_dirty = true
		update_gizmos()

## X-axis offset. The mirror part of the wing has the opposite offset.
@export var offset := 0.0:
	set(value):
		offset = value
		_dirty = true
		update_gizmos()

## Mirror wing on x axis.
@export var mirror := true:
	set(value):
		mirror = value
		_dirty = true
		update_gizmos()


@export_group("Debug")
## Enables debug view of wing sections
@export var debug: bool:
	set(value):
		if value != debug:
			debug = value
			_update_debug_view()


class WingPanel:
	var forward_left: Vector3
	var forward_right: Vector3
	var rear_right: Vector3
	var rear_left: Vector3
	var vortex_point_left: Vector3
	var vortex_point_right: Vector3
	var control_point: Vector3


var _force: Vector3
var _torque: Vector3
var _body: RigidBody3D
var _dirty := true
var _panels: Array[WingPanel]
var _debug_view: Node3D


func _enter_tree() -> void:
	_body = get_parent() as RigidBody3D
	_try_rebuild()


func _exit_tree() -> void:
	_body = null


func _physics_process(delta: float) -> void:
	if _body == null:
		return
	var state := PhysicsServer3D.body_get_direct_state(_body.get_rid())
	if state != null:
		calculate(state.linear_velocity, state.angular_velocity, _body.transform * state.center_of_mass_local)
		_body.apply_central_force(_force)
		_body.apply_torque(_torque)


func _get_configuration_warnings() -> PackedStringArray:
	var warnings := PackedStringArray()
	if get_parent() is not RigidBody3D:
		warnings.append("VehicleWing3D serves to provide a aerodynamic to a VehicleBody3D or RigidBody3D. Please use it as a child of a VehicleBody3D or RigidBody3D.")
	return warnings


## Ðœanual calculation of the force and torque generated by the wing. For example, to plot graphs.
func calculate(linear_velocity: Vector3, angular_velocity: Vector3, center_of_mass: Vector3) -> void:
	_try_rebuild()
	_force = Vector3.ZERO
	_torque = Vector3.ZERO


func _get_angle_of_attack(wind: Vector3) -> float:
	var angle := atan2(wind.y, wind.z)
	if angle > PI / 2.0:
		angle -= PI
	elif angle < -PI / 2.0:
		angle += PI
	return angle


func _try_rebuild() -> void:
	if not _dirty:
		return
	_panels.clear()
	_dirty = false
	_build_panels()
	if _debug_view != null:
		_debug_view.build()


func _build_panels() -> void:
	_panels.clear()
	var chord_panel_count := 5
	var span_panel_count := 10
	var length := span / 2.0 if mirror else span
	var dx := length / span_panel_count
	var ds := 1.0 / span_panel_count
	var dc := 1.0 / chord_panel_count
	var base := get_base()
	var tip := get_tip()
	var mac := get_mac()
	var mac_z := get_mac_forward_position()
	base.z += mac * 0.25 - mac_z
	tip += (mac * 0.25 - mac_z) * Vector3.BACK.rotated(Vector3.RIGHT, twist)
	for i in span_panel_count:
		for j in chord_panel_count:
			var panel := WingPanel.new()
			var start := i * ds
			var end := start + ds
			var start_chord := lerpf(chord, chord * taper, start)
			var end_chord := lerpf(chord, chord * taper, end)
			var start_z1 := j * start_chord / chord_panel_count - start_chord * 0.5
			var start_z2 := (j + 1) * start_chord / chord_panel_count - start_chord * 0.5
			var end_z1 := j * end_chord / chord_panel_count - end_chord * 0.5
			var end_z2 := (j + 1) * end_chord / chord_panel_count - end_chord * 0.5
			panel.forward_left = _get_wing_point(base, tip, start, start_z1, twist * start)
			panel.forward_right = _get_wing_point(base, tip, end, end_z1, twist * end)
			panel.rear_right = _get_wing_point(base, tip, end, end_z2, twist * end)
			panel.rear_left = _get_wing_point(base, tip, start, start_z2, twist * end)
			_panels.append(panel)
	if mirror:
		for i in len(_panels):
			var original := _panels[i]
			var panel := WingPanel.new()
			panel.forward_left = original.forward_right * Vector3(-1, 1, 1)
			panel.forward_right = original.forward_left * Vector3(-1, 1, 1)
			panel.rear_left = original.rear_right * Vector3(-1, 1, 1)
			panel.rear_right = original.rear_left * Vector3(-1, 1, 1)
			_panels.append(panel)
	for panel in _panels:
		panel.vortex_point_left = panel.forward_left + (panel.rear_left - panel.forward_left) * 0.25
		panel.vortex_point_right = panel.forward_right + (panel.rear_right - panel.forward_right) * 0.25
		var forward_mid := (panel.forward_left + panel.forward_right) * 0.5
		var rear_mid := (panel.rear_left + panel.rear_right) * 0.5
		panel.control_point = forward_mid + (rear_mid - forward_mid) * 0.75


func _get_wing_point(base: Vector3, tip: Vector3, pos: float, chord: float, twist: float) -> Vector3:
	var point := base + (tip - base) * pos
	var twist_dir := Vector3.BACK.rotated(Vector3.RIGHT, twist)
	point += twist_dir * chord
	return point


## Returns position of wing base
func get_base() -> Vector3:
	return Vector3.RIGHT * offset


## Returns position of wing tip
func get_tip() -> Vector3:
	var direction := Vector3.RIGHT
	direction = direction.rotated(Vector3.DOWN, sweep)
	direction = direction.rotated(Vector3.BACK, dihedral)
	var tip := direction * get_console_length() / direction.x
	return get_base() + tip


## Returns console length
func get_console_length() -> float:
	return span / 2.0 - offset if mirror else span - offset


## Returns the mean aerodynamic chord of wing.
func get_mac() -> float:
	return 2.0 / 3.0 * chord * (1.0 + taper + taper * taper) / (1.0 + taper)


## Returns x-axis distance to mac
func get_mac_right_position() -> float:
	var length := get_console_length() * 2.0 if mirror else get_console_length()
	return length / 6.0 * (1.0 + 2.0 * taper) / (1.0 + taper)


## Returns z-axis distance to mac
func get_mac_forward_position() -> float:
	var mac := get_mac()
	var pos := mac / 4.0 * (1.0 - taper)
	if sweep != 0.0:
		pos += tan(sweep) * get_mac_right_position()
	return pos - (chord - mac) * 0.5


## Returns the force generated by the wing.
func get_force() -> Vector3:
	return _force


## Returns the torque generated by the wing.
func get_torque() -> Vector3:
	return _torque


var VehicleWing3DDebugView := preload("uid://ep1ok4t4lxt0")
func _update_debug_view() -> void:
	if _debug_view != null:
		_debug_view.queue_free()
		_debug_view = null
	if debug:
		_debug_view = VehicleWing3DDebugView.new()
		add_child(_debug_view)
