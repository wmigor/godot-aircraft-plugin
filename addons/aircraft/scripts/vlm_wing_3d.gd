@tool
@icon("uid://dgp1egfjl2whe")
extends Node3D
class_name VlmWing3D

@export_group("Airfoil")
@export_range(0.0, 9.5) var camber_max := 2.0:
	set(value):
		camber_max = value
		_shape_dirty = true
		update_gizmos()

@export_range(0.0, 9.0) var camber_max_position := 4.0:
	set(value):
		camber_max_position = value
		_shape_dirty = true
		update_gizmos()


@export_group("Shape")
## Wing span. Distance between wingtips.
@export var span := 4.0:
	set(value):
		span = value
		_shape_dirty = true
		update_gizmos()

## Wing chord at the base.
@export var chord := 0.5:
	set(value):
		chord = value
		_shape_dirty = true
		update_gizmos()

## Taper of the wing at the tip relative to the base.
@export_range(0, 1) var taper := 1.0:
	set(value):
		taper = value
		_shape_dirty = true
		update_gizmos()

## Wing twist angle.
@export_range(-15, 15, 0.001, "radians_as_degrees") var twist := 0.0:
	set(value):
		twist = value
		_shape_dirty = true
		update_gizmos()

## Wing sweep angle.
@export_range(-70, 70, 0.001, "radians_as_degrees") var sweep := 0.0:
	set(value):
		sweep = value
		_shape_dirty = true
		update_gizmos()

## Wing dihedral angle.
@export_range(-30, 30, 0.001, "radians_as_degrees") var dihedral := 0.0:
	set(value):
		dihedral = value
		_shape_dirty = true
		update_gizmos()

## X-axis offset. The mirror part of the wing has the opposite offset.
@export var offset := 0.0:
	set(value):
		offset = value
		_shape_dirty = true
		update_gizmos()

## Mirror wing on x axis.
@export var mirror := true:
	set(value):
		mirror = value
		_shape_dirty = true
		update_gizmos()


@export_group("Debug")
## Enables debug view of wing sections
@export var debug: bool:
	set(value):
		if value != debug:
			debug = value
			_update_debug_view()


class WingPanel:
	var front_left: Vector3
	var front_right: Vector3
	var back_right: Vector3
	var back_left: Vector3
	var vortex_left: Vector3
	var vortex_right: Vector3
	var vortex_center: Vector3
	var control_point: Vector3
	var normal: Vector3
	var area: float


var _force: Vector3
var _torque: Vector3
var _body: RigidBody3D
var _shape_dirty := true
var _matrix_dirty := true
var _panels: Array[WingPanel]
var _debug_view: Node3D
var _aic_matrix: Array[Array]


func _enter_tree() -> void:
	_body = get_parent() as RigidBody3D
	_try_rebuild_shape()


func _exit_tree() -> void:
	_body = null


func _physics_process(delta: float) -> void:
	if _body == null:
		return
	var state := PhysicsServer3D.body_get_direct_state(_body.get_rid())
	if state != null:
		calculate(state.linear_velocity, state.angular_velocity, _body.transform * state.center_of_mass_local)
		_body.apply_central_force(_force)
		_body.apply_torque(_torque)


func _get_configuration_warnings() -> PackedStringArray:
	var warnings := PackedStringArray()
	if get_parent() is not RigidBody3D:
		warnings.append("VehicleWing3D serves to provide a aerodynamic to a VehicleBody3D or RigidBody3D. Please use it as a child of a VehicleBody3D or RigidBody3D.")
	return warnings


## Ðœanual calculation of the force and torque generated by the wing. For example, to plot graphs.
func calculate(linear_velocity: Vector3, angular_velocity: Vector3, center_of_mass: Vector3) -> void:
	if Engine.is_editor_hint():
		return
	_try_rebuild_shape()
	_try_rebuild_matrix()
	_force = Vector3.ZERO
	_torque = Vector3.ZERO


func _get_angle_of_attack(wind: Vector3) -> float:
	var angle := atan2(wind.y, wind.z)
	if angle > PI / 2.0:
		angle -= PI
	elif angle < -PI / 2.0:
		angle += PI
	return angle


func _try_rebuild_shape() -> void:
	if not _shape_dirty:
		return
	_shape_dirty = false
	_matrix_dirty = true
	_build_panels()
	if _debug_view != null:
		_debug_view.build()


func _try_rebuild_matrix() -> void:
	if _matrix_dirty:
		_build_aic_matrix()
		_matrix_dirty = false


func _build_panels() -> void:
	_panels.clear()
	var chord_panel_count := 8
	var span_panel_count := 16
	var length := span / 2.0 if mirror else span
	var dx := length / span_panel_count
	var ds := 1.0 / span_panel_count
	var dc := 1.0 / chord_panel_count
	var base := get_base()
	var tip := get_tip()
	var mac := get_mac()
	var mac_z := get_mac_forward_position()
	base.z += mac * 0.25 - mac_z
	tip += (mac * 0.25 - mac_z) * Vector3.BACK.rotated(Vector3.RIGHT, twist)
	for i in span_panel_count:
		for j in chord_panel_count:
			var panel := WingPanel.new()
			var start := i * ds
			var end := start + ds
			var start_chord := lerpf(chord, chord * taper, start)
			var end_chord := lerpf(chord, chord * taper, end)
			var start_z1 := j * start_chord / chord_panel_count - start_chord * 0.5
			var start_z2 := (j + 1) * start_chord / chord_panel_count - start_chord * 0.5
			var end_z1 := j * end_chord / chord_panel_count - end_chord * 0.5
			var end_z2 := (j + 1) * end_chord / chord_panel_count - end_chord * 0.5
			panel.front_left = _get_wing_point(base, tip, start, start_z1, twist * start)
			panel.front_right = _get_wing_point(base, tip, end, end_z1, twist * end)
			panel.back_right = _get_wing_point(base, tip, end, end_z2, twist * end)
			panel.back_left = _get_wing_point(base, tip, start, start_z2, twist * end)
			_panels.append(panel)
			var front_left := _get_wing_point(base, tip, start, -chord * 0.5, twist * start) - _get_wing_point(base, tip, start, chord * 0.5, twist * start)
			var normal_left := (tip - base).cross(front_left).normalized()
			panel.front_left += normal_left * _get_camber_line(1.0 - (start_chord / 2.0 - start_z1) / start_chord)
			panel.back_left += normal_left * _get_camber_line(1.0 - (start_chord / 2.0 - start_z2) / start_chord)
			var front_right := _get_wing_point(base, tip, end, -chord * 0.5, twist * end) - _get_wing_point(base, tip, end, chord * 0.5, twist * end)
			var normal_right := (tip - base).cross(front_right).normalized()
			panel.front_right += normal_right * _get_camber_line(1.0 - (end_chord / 2.0 - end_z1) / end_chord)
			panel.back_right += normal_right * _get_camber_line(1.0 - (end_chord / 2.0 - end_z2) / end_chord)
	if mirror:
		for i in len(_panels):
			var original := _panels[i]
			var panel := WingPanel.new()
			panel.front_left = original.front_right * Vector3(-1, 1, 1)
			panel.front_right = original.front_left * Vector3(-1, 1, 1)
			panel.back_left = original.back_right * Vector3(-1, 1, 1)
			panel.back_right = original.back_left * Vector3(-1, 1, 1)
			_panels.append(panel)
	for panel in _panels:
		panel.vortex_left = panel.front_left + (panel.back_left - panel.front_left) * 0.25
		panel.vortex_right = panel.front_right + (panel.back_right - panel.front_right) * 0.25
		panel.vortex_center = (panel.vortex_left + panel.vortex_right) * 0.5
		var forward_mid := (panel.front_left + panel.front_right) * 0.5
		var rear_mid := (panel.back_left + panel.back_right) * 0.5
		panel.control_point = forward_mid + (rear_mid - forward_mid) * 0.75
		var diagonal1 := panel.front_right - panel.back_left
		var diagonal2 := panel.front_left - panel.back_right
		var cross := diagonal1.cross(diagonal2)
		panel.normal = cross.normalized()
		panel.area = cross.length() / 2.0


func _build_aic_matrix() -> void:
	var count := len(_panels)
	if len(_aic_matrix) != count and len(_aic_matrix) > 0:
		_aic_matrix.clear()
	if len(_aic_matrix) <= 0:
		for i in count:
			var row: Array[float]
			row.resize(count)
			_aic_matrix.append(row)
	for i in count:
		var panel1 := _panels[i]
		for j in count:
			var panel2 := _panels[j]
			var bound_vortex := _get_bound_vortex(panel2.vortex_left, panel2.vortex_right, panel1.control_point)
			var trailing_vortex1 := _get_trailing_vortex(panel2.vortex_left, panel1.control_point, Vector3.BACK)
			var trailing_vortex2 := _get_trailing_vortex(panel2.vortex_right, panel1.control_point, Vector3.BACK)
			var vortex := bound_vortex + trailing_vortex1 + trailing_vortex2
			var velocity_induced := vortex.dot(panel1.normal)
			_aic_matrix[i][j] = velocity_induced


func _get_bound_vortex(vortex_point1: Vector3, vortex_point2: Vector3, control_point: Vector3, gamma := 1.0) -> Vector3:
	var d1 := vortex_point1 - control_point
	var d2 := vortex_point2 - control_point
	var cross := d1.cross(d2)
	var cross_length := cross.length()
	var part1 := cross / (cross_length * cross_length)
	var part2 := d1.dot(d2) / (d1.length() * d2.length()) - 1.0

	return gamma / (4.0 * PI) * part1 * part2


func _get_trailing_vortex(vortex_point: Vector3, control_point: Vector3, direction: Vector3, gamma := 1.0) -> Vector3:
	var delta := control_point - vortex_point
	var cross := direction.cross(delta)
	var cross_length := cross.length()
	var part1 := cross / (cross_length * cross_length)
	var part2 := 1.0 + direction.dot(delta) / (direction.length() * delta.length())

	return gamma / (4.0 * PI) * part1 * part2


func _get_wing_point(base: Vector3, tip: Vector3, pos: float, chord: float, twist: float) -> Vector3:
	var point := base + (tip - base) * pos
	var twist_dir := Vector3.BACK.rotated(Vector3.RIGHT, twist)
	point += twist_dir * chord
	return point


func _get_camber_line(x: float) -> float:
	x = clampf(x, 0.0, 1.0)
	var m := camber_max / 100.0
	var p := camber_max_position / 10.0
	if p <= 0.0:
		return 0.0
	if x < p:
		return (m / (p * p)) * x * (2.0 * p - x)
	return (m / (1.0 - p) / (1.0 - p)) * (1.0 - 2.0 * p + x * (2.0 * p - x))


## Returns position of wing base
func get_base() -> Vector3:
	return Vector3.RIGHT * offset


## Returns position of wing tip
func get_tip() -> Vector3:
	var direction := Vector3.RIGHT
	direction = direction.rotated(Vector3.DOWN, sweep)
	direction = direction.rotated(Vector3.BACK, dihedral)
	var tip := direction * get_console_length() / direction.x
	return get_base() + tip


## Returns console length
func get_console_length() -> float:
	return span / 2.0 - offset if mirror else span - offset


## Returns the mean aerodynamic chord of wing.
func get_mac() -> float:
	return 2.0 / 3.0 * chord * (1.0 + taper + taper * taper) / (1.0 + taper)


## Returns x-axis distance to mac
func get_mac_right_position() -> float:
	var length := get_console_length() * 2.0 if mirror else get_console_length()
	return length / 6.0 * (1.0 + 2.0 * taper) / (1.0 + taper)


## Returns z-axis distance to mac
func get_mac_forward_position() -> float:
	var mac := get_mac()
	var pos := mac / 4.0 * (1.0 - taper)
	if sweep != 0.0:
		pos += tan(sweep) * get_mac_right_position()
	return pos - (chord - mac) * 0.5


## Returns the force generated by the wing.
func get_force() -> Vector3:
	return _force


## Returns the torque generated by the wing.
func get_torque() -> Vector3:
	return _torque


var VlmWing3DDebugView := preload("uid://dbiuk00c8y5gs")
func _update_debug_view() -> void:
	if _debug_view != null:
		_debug_view.queue_free()
		_debug_view = null
	if debug:
		_debug_view = VlmWing3DDebugView.new()
		add_child(_debug_view)
